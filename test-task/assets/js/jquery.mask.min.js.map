{"version":3,"file":"jquery.mask.min.js","sources":["jquery.mask.js"],"sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/**\n * jquery.mask.js\n * @version: v1.14.16\n * @author: Igor Escobar\n *\n * Created by Igor Escobar on 2012-03-10. Please report any bug at github.com/igorescobar/jQuery-Mask-Plugin\n *\n * Copyright (c) 2012 Igor Escobar http://igorescobar.com\n *\n * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* jshint laxbreak: true */\n/* jshint maxcomplexity:17 */\n/* global define */\n\n// UMD (Universal Module Definition) patterns for JavaScript modules that work everywhere.\n// https://github.com/umdjs/umd/blob/master/templates/jqueryPlugin.js\n(function (factory, jQuery, Zepto) {\n  if (typeof define === 'function' && define.amd) {\n    define(['jquery'], factory);\n  } else if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object' && typeof Meteor === 'undefined') {\n    module.exports = factory(require('jquery'));\n  } else {\n    factory(jQuery || Zepto);\n  }\n})(function ($) {\n  'use strict';\n\n  var Mask = function Mask(el, mask, options) {\n    var p = {\n      invalid: [],\n      getCaret: function getCaret() {\n        try {\n          var sel,\n            pos = 0,\n            ctrl = el.get(0),\n            dSel = document.selection,\n            cSelStart = ctrl.selectionStart;\n\n          // IE Support\n          if (dSel && navigator.appVersion.indexOf('MSIE 10') === -1) {\n            sel = dSel.createRange();\n            sel.moveStart('character', -p.val().length);\n            pos = sel.text.length;\n          }\n          // Firefox support\n          else if (cSelStart || cSelStart === '0') {\n            pos = cSelStart;\n          }\n          return pos;\n        } catch (e) {}\n      },\n      setCaret: function setCaret(pos) {\n        try {\n          if (el.is(':focus')) {\n            var range,\n              ctrl = el.get(0);\n\n            // Firefox, WebKit, etc..\n            if (ctrl.setSelectionRange) {\n              ctrl.setSelectionRange(pos, pos);\n            } else {\n              // IE\n              range = ctrl.createTextRange();\n              range.collapse(true);\n              range.moveEnd('character', pos);\n              range.moveStart('character', pos);\n              range.select();\n            }\n          }\n        } catch (e) {}\n      },\n      events: function events() {\n        el.on('keydown.mask', function (e) {\n          el.data('mask-keycode', e.keyCode || e.which);\n          el.data('mask-previus-value', el.val());\n          el.data('mask-previus-caret-pos', p.getCaret());\n          p.maskDigitPosMapOld = p.maskDigitPosMap;\n        }).on($.jMaskGlobals.useInput ? 'input.mask' : 'keyup.mask', p.behaviour).on('paste.mask drop.mask', function () {\n          setTimeout(function () {\n            el.keydown().keyup();\n          }, 100);\n        }).on('change.mask', function () {\n          el.data('changed', true);\n        }).on('blur.mask', function () {\n          if (oldValue !== p.val() && !el.data('changed')) {\n            el.trigger('change');\n          }\n          el.data('changed', false);\n        })\n        // it's very important that this callback remains in this position\n        // otherwhise oldValue it's going to work buggy\n        .on('blur.mask', function () {\n          oldValue = p.val();\n        })\n        // select all text on focus\n        .on('focus.mask', function (e) {\n          if (options.selectOnFocus === true) {\n            $(e.target).select();\n          }\n        })\n        // clear the value if it not complete the mask\n        .on('focusout.mask', function () {\n          if (options.clearIfNotMatch && !regexMask.test(p.val())) {\n            p.val('');\n          }\n        });\n      },\n      getRegexMask: function getRegexMask() {\n        var maskChunks = [],\n          translation,\n          pattern,\n          optional,\n          recursive,\n          oRecursive,\n          r;\n        for (var i = 0; i < mask.length; i++) {\n          translation = jMask.translation[mask.charAt(i)];\n          if (translation) {\n            pattern = translation.pattern.toString().replace(/.{1}$|^.{1}/g, '');\n            optional = translation.optional;\n            recursive = translation.recursive;\n            if (recursive) {\n              maskChunks.push(mask.charAt(i));\n              oRecursive = {\n                digit: mask.charAt(i),\n                pattern: pattern\n              };\n            } else {\n              maskChunks.push(!optional && !recursive ? pattern : pattern + '?');\n            }\n          } else {\n            maskChunks.push(mask.charAt(i).replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'));\n          }\n        }\n        r = maskChunks.join('');\n        if (oRecursive) {\n          r = r.replace(new RegExp('(' + oRecursive.digit + '(.*' + oRecursive.digit + ')?)'), '($1)?').replace(new RegExp(oRecursive.digit, 'g'), oRecursive.pattern);\n        }\n        return new RegExp(r);\n      },\n      destroyEvents: function destroyEvents() {\n        el.off(['input', 'keydown', 'keyup', 'paste', 'drop', 'blur', 'focusout', ''].join('.mask '));\n      },\n      val: function val(v) {\n        var isInput = el.is('input'),\n          method = isInput ? 'val' : 'text',\n          r;\n        if (arguments.length > 0) {\n          if (el[method]() !== v) {\n            el[method](v);\n          }\n          r = el;\n        } else {\n          r = el[method]();\n        }\n        return r;\n      },\n      calculateCaretPosition: function calculateCaretPosition(oldVal) {\n        var newVal = p.getMasked(),\n          caretPosNew = p.getCaret();\n        if (oldVal !== newVal) {\n          var caretPosOld = el.data('mask-previus-caret-pos') || 0,\n            newValL = newVal.length,\n            oldValL = oldVal.length,\n            maskDigitsBeforeCaret = 0,\n            maskDigitsAfterCaret = 0,\n            maskDigitsBeforeCaretAll = 0,\n            maskDigitsBeforeCaretAllOld = 0,\n            i = 0;\n          for (i = caretPosNew; i < newValL; i++) {\n            if (!p.maskDigitPosMap[i]) {\n              break;\n            }\n            maskDigitsAfterCaret++;\n          }\n          for (i = caretPosNew - 1; i >= 0; i--) {\n            if (!p.maskDigitPosMap[i]) {\n              break;\n            }\n            maskDigitsBeforeCaret++;\n          }\n          for (i = caretPosNew - 1; i >= 0; i--) {\n            if (p.maskDigitPosMap[i]) {\n              maskDigitsBeforeCaretAll++;\n            }\n          }\n          for (i = caretPosOld - 1; i >= 0; i--) {\n            if (p.maskDigitPosMapOld[i]) {\n              maskDigitsBeforeCaretAllOld++;\n            }\n          }\n\n          // if the cursor is at the end keep it there\n          if (caretPosNew > oldValL) {\n            caretPosNew = newValL * 10;\n          } else if (caretPosOld >= caretPosNew && caretPosOld !== oldValL) {\n            if (!p.maskDigitPosMapOld[caretPosNew]) {\n              var caretPos = caretPosNew;\n              caretPosNew -= maskDigitsBeforeCaretAllOld - maskDigitsBeforeCaretAll;\n              caretPosNew -= maskDigitsBeforeCaret;\n              if (p.maskDigitPosMap[caretPosNew]) {\n                caretPosNew = caretPos;\n              }\n            }\n          } else if (caretPosNew > caretPosOld) {\n            caretPosNew += maskDigitsBeforeCaretAll - maskDigitsBeforeCaretAllOld;\n            caretPosNew += maskDigitsAfterCaret;\n          }\n        }\n        return caretPosNew;\n      },\n      behaviour: function behaviour(e) {\n        e = e || window.event;\n        p.invalid = [];\n        var keyCode = el.data('mask-keycode');\n        if ($.inArray(keyCode, jMask.byPassKeys) === -1) {\n          var newVal = p.getMasked(),\n            caretPos = p.getCaret(),\n            oldVal = el.data('mask-previus-value') || '';\n\n          // this is a compensation to devices/browsers that don't compensate\n          // caret positioning the right way\n          setTimeout(function () {\n            p.setCaret(p.calculateCaretPosition(oldVal));\n          }, $.jMaskGlobals.keyStrokeCompensation);\n          p.val(newVal);\n          p.setCaret(caretPos);\n          return p.callbacks(e);\n        }\n      },\n      getMasked: function getMasked(skipMaskChars, val) {\n        var buf = [],\n          value = val === undefined ? p.val() : val + '',\n          m = 0,\n          maskLen = mask.length,\n          v = 0,\n          valLen = value.length,\n          offset = 1,\n          addMethod = 'push',\n          resetPos = -1,\n          maskDigitCount = 0,\n          maskDigitPosArr = [],\n          lastMaskChar,\n          check;\n        if (options.reverse) {\n          addMethod = 'unshift';\n          offset = -1;\n          lastMaskChar = 0;\n          m = maskLen - 1;\n          v = valLen - 1;\n          check = function check() {\n            return m > -1 && v > -1;\n          };\n        } else {\n          lastMaskChar = maskLen - 1;\n          check = function check() {\n            return m < maskLen && v < valLen;\n          };\n        }\n        var lastUntranslatedMaskChar;\n        while (check()) {\n          var maskDigit = mask.charAt(m),\n            valDigit = value.charAt(v),\n            translation = jMask.translation[maskDigit];\n          if (translation) {\n            if (valDigit.match(translation.pattern)) {\n              buf[addMethod](valDigit);\n              if (translation.recursive) {\n                if (resetPos === -1) {\n                  resetPos = m;\n                } else if (m === lastMaskChar && m !== resetPos) {\n                  m = resetPos - offset;\n                }\n                if (lastMaskChar === resetPos) {\n                  m -= offset;\n                }\n              }\n              m += offset;\n            } else if (valDigit === lastUntranslatedMaskChar) {\n              // matched the last untranslated (raw) mask character that we encountered\n              // likely an insert offset the mask character from the last entry; fall\n              // through and only increment v\n              maskDigitCount--;\n              lastUntranslatedMaskChar = undefined;\n            } else if (translation.optional) {\n              m += offset;\n              v -= offset;\n            } else if (translation.fallback) {\n              buf[addMethod](translation.fallback);\n              m += offset;\n              v -= offset;\n            } else {\n              p.invalid.push({\n                p: v,\n                v: valDigit,\n                e: translation.pattern\n              });\n            }\n            v += offset;\n          } else {\n            if (!skipMaskChars) {\n              buf[addMethod](maskDigit);\n            }\n            if (valDigit === maskDigit) {\n              maskDigitPosArr.push(v);\n              v += offset;\n            } else {\n              lastUntranslatedMaskChar = maskDigit;\n              maskDigitPosArr.push(v + maskDigitCount);\n              maskDigitCount++;\n            }\n            m += offset;\n          }\n        }\n        var lastMaskCharDigit = mask.charAt(lastMaskChar);\n        if (maskLen === valLen + 1 && !jMask.translation[lastMaskCharDigit]) {\n          buf.push(lastMaskCharDigit);\n        }\n        var newVal = buf.join('');\n        p.mapMaskdigitPositions(newVal, maskDigitPosArr, valLen);\n        return newVal;\n      },\n      mapMaskdigitPositions: function mapMaskdigitPositions(newVal, maskDigitPosArr, valLen) {\n        var maskDiff = options.reverse ? newVal.length - valLen : 0;\n        p.maskDigitPosMap = {};\n        for (var i = 0; i < maskDigitPosArr.length; i++) {\n          p.maskDigitPosMap[maskDigitPosArr[i] + maskDiff] = 1;\n        }\n      },\n      callbacks: function callbacks(e) {\n        var val = p.val(),\n          changed = val !== oldValue,\n          defaultArgs = [val, e, el, options],\n          callback = function callback(name, criteria, args) {\n            if (typeof options[name] === 'function' && criteria) {\n              options[name].apply(this, args);\n            }\n          };\n        callback('onChange', changed === true, defaultArgs);\n        callback('onKeyPress', changed === true, defaultArgs);\n        callback('onComplete', val.length === mask.length, defaultArgs);\n        callback('onInvalid', p.invalid.length > 0, [val, e, el, p.invalid, options]);\n      }\n    };\n    el = $(el);\n    var jMask = this,\n      oldValue = p.val(),\n      regexMask;\n    mask = typeof mask === 'function' ? mask(p.val(), undefined, el, options) : mask;\n\n    // public methods\n    jMask.mask = mask;\n    jMask.options = options;\n    jMask.remove = function () {\n      var caret = p.getCaret();\n      if (jMask.options.placeholder) {\n        el.removeAttr('placeholder');\n      }\n      if (el.data('mask-maxlength')) {\n        el.removeAttr('maxlength');\n      }\n      p.destroyEvents();\n      p.val(jMask.getCleanVal());\n      p.setCaret(caret);\n      return el;\n    };\n\n    // get value without mask\n    jMask.getCleanVal = function () {\n      return p.getMasked(true);\n    };\n\n    // get masked value without the value being in the input or element\n    jMask.getMaskedVal = function (val) {\n      return p.getMasked(false, val);\n    };\n    jMask.init = function (onlyMask) {\n      onlyMask = onlyMask || false;\n      options = options || {};\n      jMask.clearIfNotMatch = $.jMaskGlobals.clearIfNotMatch;\n      jMask.byPassKeys = $.jMaskGlobals.byPassKeys;\n      jMask.translation = $.extend({}, $.jMaskGlobals.translation, options.translation);\n      jMask = $.extend(true, {}, jMask, options);\n      regexMask = p.getRegexMask();\n      if (onlyMask) {\n        p.events();\n        p.val(p.getMasked());\n      } else {\n        if (options.placeholder) {\n          el.attr('placeholder', options.placeholder);\n        }\n\n        // this is necessary, otherwise if the user submit the form\n        // and then press the \"back\" button, the autocomplete will erase\n        // the data. Works fine on IE9+, FF, Opera, Safari.\n        if (el.data('mask')) {\n          el.attr('autocomplete', 'off');\n        }\n\n        // detect if is necessary let the user type freely.\n        // for is a lot faster than forEach.\n        for (var i = 0, maxlength = true; i < mask.length; i++) {\n          var translation = jMask.translation[mask.charAt(i)];\n          if (translation && translation.recursive) {\n            maxlength = false;\n            break;\n          }\n        }\n        if (maxlength) {\n          el.attr('maxlength', mask.length).data('mask-maxlength', true);\n        }\n        p.destroyEvents();\n        p.events();\n        var caret = p.getCaret();\n        p.val(p.getMasked());\n        p.setCaret(caret);\n      }\n    };\n    jMask.init(!el.is('input'));\n  };\n  $.maskWatchers = {};\n  var HTMLAttributes = function HTMLAttributes() {\n      var input = $(this),\n        options = {},\n        prefix = 'data-mask-',\n        mask = input.attr('data-mask');\n      if (input.attr(prefix + 'reverse')) {\n        options.reverse = true;\n      }\n      if (input.attr(prefix + 'clearifnotmatch')) {\n        options.clearIfNotMatch = true;\n      }\n      if (input.attr(prefix + 'selectonfocus') === 'true') {\n        options.selectOnFocus = true;\n      }\n      if (notSameMaskObject(input, mask, options)) {\n        return input.data('mask', new Mask(this, mask, options));\n      }\n    },\n    notSameMaskObject = function notSameMaskObject(field, mask, options) {\n      options = options || {};\n      var maskObject = $(field).data('mask'),\n        stringify = JSON.stringify,\n        value = $(field).val() || $(field).text();\n      try {\n        if (typeof mask === 'function') {\n          mask = mask(value);\n        }\n        return _typeof(maskObject) !== 'object' || stringify(maskObject.options) !== stringify(options) || maskObject.mask !== mask;\n      } catch (e) {}\n    },\n    eventSupported = function eventSupported(eventName) {\n      var el = document.createElement('div'),\n        isSupported;\n      eventName = 'on' + eventName;\n      isSupported = eventName in el;\n      if (!isSupported) {\n        el.setAttribute(eventName, 'return;');\n        isSupported = typeof el[eventName] === 'function';\n      }\n      el = null;\n      return isSupported;\n    };\n  $.fn.mask = function (mask, options) {\n    options = options || {};\n    var selector = this.selector,\n      globals = $.jMaskGlobals,\n      interval = globals.watchInterval,\n      watchInputs = options.watchInputs || globals.watchInputs,\n      maskFunction = function maskFunction() {\n        if (notSameMaskObject(this, mask, options)) {\n          return $(this).data('mask', new Mask(this, mask, options));\n        }\n      };\n    $(this).each(maskFunction);\n    if (selector && selector !== '' && watchInputs) {\n      clearInterval($.maskWatchers[selector]);\n      $.maskWatchers[selector] = setInterval(function () {\n        $(document).find(selector).each(maskFunction);\n      }, interval);\n    }\n    return this;\n  };\n  $.fn.masked = function (val) {\n    return this.data('mask').getMaskedVal(val);\n  };\n  $.fn.unmask = function () {\n    clearInterval($.maskWatchers[this.selector]);\n    delete $.maskWatchers[this.selector];\n    return this.each(function () {\n      var dataMask = $(this).data('mask');\n      if (dataMask) {\n        dataMask.remove().removeData('mask');\n      }\n    });\n  };\n  $.fn.cleanVal = function () {\n    return this.data('mask').getCleanVal();\n  };\n  $.applyDataMask = function (selector) {\n    selector = selector || $.jMaskGlobals.maskElements;\n    var $selector = selector instanceof $ ? selector : $(selector);\n    $selector.filter($.jMaskGlobals.dataMaskAttr).each(HTMLAttributes);\n  };\n  var globals = {\n    maskElements: 'input,td,span,div',\n    dataMaskAttr: '[data-mask]',\n    dataMask: true,\n    watchInterval: 300,\n    watchInputs: true,\n    keyStrokeCompensation: 10,\n    // old versions of chrome dont work great with input event\n    useInput: !/Chrome\\/[2-4][0-9]|SamsungBrowser/.test(window.navigator.userAgent) && eventSupported('input'),\n    watchDataMask: false,\n    byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],\n    translation: {\n      '0': {\n        pattern: /\\d/\n      },\n      '9': {\n        pattern: /\\d/,\n        optional: true\n      },\n      '#': {\n        pattern: /\\d/,\n        recursive: true\n      },\n      'A': {\n        pattern: /[a-zA-Z0-9]/\n      },\n      'S': {\n        pattern: /[a-zA-Z]/\n      }\n    }\n  };\n  $.jMaskGlobals = $.jMaskGlobals || {};\n  globals = $.jMaskGlobals = $.extend(true, {}, globals, $.jMaskGlobals);\n\n  // looking for inputs with data-mask attribute\n  if (globals.dataMask) {\n    $.applyDataMask();\n  }\n  setInterval(function () {\n    if ($.jMaskGlobals.watchDataMask) {\n      $.applyDataMask();\n    }\n  }, globals.watchInterval);\n}, window.jQuery, window.Zepto);"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","factory","jQuery","Zepto","define","amd","exports","Meteor","module","require","$","Mask","el","mask","options","regexMask","p","invalid","getCaret","sel","pos","ctrl","get","dSel","document","selection","cSelStart","selectionStart","navigator","appVersion","indexOf","createRange","moveStart","val","length","text","e","setCaret","range","is","setSelectionRange","createTextRange","collapse","moveEnd","select","events","on","data","keyCode","which","maskDigitPosMapOld","maskDigitPosMap","jMaskGlobals","useInput","behaviour","setTimeout","keydown","keyup","oldValue","trigger","selectOnFocus","target","clearIfNotMatch","test","getRegexMask","pattern","optional","recursive","oRecursive","r","maskChunks","i","translation","jMask","charAt","toString","replace","push","digit","join","RegExp","destroyEvents","off","v","method","arguments","calculateCaretPosition","oldVal","newVal","getMasked","caretPosNew","caretPosOld","newValL","oldValL","maskDigitsBeforeCaret","maskDigitsAfterCaret","maskDigitsBeforeCaretAll","maskDigitsBeforeCaretAllOld","caretPos","window","event","inArray","byPassKeys","keyStrokeCompensation","callbacks","skipMaskChars","lastMaskChar","lastUntranslatedMaskChar","buf","value","undefined","m","maskLen","valLen","offset","addMethod","resetPos","maskDigitCount","maskDigitPosArr","check","reverse","maskDigit","valDigit","match","fallback","lastMaskCharDigit","mapMaskdigitPositions","maskDiff","callback","name","criteria","args","apply","this","changed","defaultArgs","remove","caret","placeholder","removeAttr","getCleanVal","getMaskedVal","init","onlyMask","extend","attr","maxlength","HTMLAttributes","input","prefix","notSameMaskObject","field","maskObject","stringify","JSON","maskWatchers","fn","maskFunction","selector","globals","interval","watchInterval","watchInputs","each","clearInterval","setInterval","find","masked","unmask","dataMask","removeData","cleanVal","applyDataMask","maskElements","filter","dataMaskAttr","isSupported","userAgent","eventName","createElement","setAttribute","watchDataMask","0","9","#","A","S"],"mappings":"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"}